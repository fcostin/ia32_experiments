design a more workable stack-based language
for writing a brainfuck->ia32 compiler
that may be compiled to vanilla brainfuck

high-level functionality:
	* run-length encode input program
		(to enable better code generation for
		 long sequences of increments, etc)
	* some kind of pattern matching / switched dispatch construct
		(to match runs of input)
	* conversions from int to ascii glyphs for int

design
	* stack machine
	* "the simplest thing that works in general"
		for the bare minimum level of generality required
	* stack holds typed structures
		- how to encode?
		- null terminated lists?
		e.g. to store struct of type T1 with content {a, b, c};
			[END T1][VAR c][VAR b][VAR a][BEGIN T1]
		e.g. to store boxed int x
			[END INT][VAR x][BEGIN INT]
		or perhaps
			[INT x]
		with INT being recognised as a builtin thingamy

		this encoding is implementation detail
		but it can be done

		actually, probably dont need the [END T1] thing
		since size of T1 known at compile time


opcodes:

get_char: () -> (int)
	# builtin

type run_t {
	c : int
	n : int
}

run_unit: () -> (run_t)
	return run_t(0, 0)

run_get_char: () -> (run_t)
	return run_t(get_char(), 1)

run_is_eof: (x : run_t) -> (int)
	switch:
		case x.c == EOF:
			return 1
		default:
			return 0

run_can_merge: (x : run_t, y : run_t) -> (int)
	switch:
		case x.c == y.c:
			return 1
		case x.n == 0:
			return 1
		case y.n == 0:
			return 1
		default:
			return 0

run_merge: (x : run_t, y : run_t) -> (run_t)
	switch:
		case x.c == y.c:
			return run_t(x.c, x.n + y.n)
		case x.n == 0:
			return run_t(y.c, y.n)
		default:
			return run_t(x.c, x.n)

type input_t {
	acc : run_t
	next : run_t
}

input_update: (acc : run_t, next : run_t) -> (input_x)
	while ((not run_is_eof(next)) and run_can_merge(acc, next)):
		acc <- run_merge(acc, next)
		next <- run_get_char()
	return input_t(acc, next)

input_init: () -> (input_t)
	return input_update(run_unit(), run_get_char())

input_is_eof: (x : input_t) -> (int)
	return run_is_eof(x.acc)

input_get_run: (x : input_t) -> (run_t)
	
NOPE!

where are we going with this?
	it's some awful complicated imperative language
	what's this got to do with stack operations?
